I"3<div class="card h-100 my-u-padding"><div class="insertcover"><a target="_blank" class="text-dark" href="https://programmers.co.kr/learn/courses/30/lessons/64062"><div class=""><img class="inserturl" src="/assets/images/study/programmers.png" alt="programmers.co.kr" /></div><div class="insert-img-body"><h4 class="insert-img-title">2019 카카오 개발자 겨울 인턴십 : 징검다리 건너기</h4><p class="insert-img-description">programmers.co.kr</p></div></a></div></div>

<p>[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] = 완전탐색으로 풀면 0 점이라는 소리다.
보통 이런 문제의 가장 큰 해결 방안 중 하나는 이분 탐색이다.</p>

<p>그렇지만 문제에서 설명하는 대로 문제를 해결하다 보면 방법이 결국에는 완전탐색쪽으로 떠오른다. <br /></p>

<p>이 문제를 살펴보면 stone의 값이 결국 걸어갈 수 있는 인원을 나타내므로 stone의 가장 적은 값부터 빼주되 처음 0이하가 되는 index를 true로 하는 배열을 가질 수 있다.
이 배열에서 true를 가지는 index의 연속적인 개수가 k값보다 커지는 직후의 순간을 찾아내도록 하는 방법이 하나의 방법이 될수 있는데, 이는 완전탐색이다. <br /></p>

<p>아래가 위의 방법을 풀어본 예시이다.
아래에선 stones의 값을 중복을 제거 한후 내림차순 정렬을 하게 되면 해당 값들이 각각의 배열 안에서 0이 되는 값이기 때문에
그 값의 index를 찾아주면 k값을 검사할수 있게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">fun</span> <span class="nf">solution</span><span class="o">(</span><span class="nl">stones:</span> <span class="nc">IntArray</span><span class="o">,</span> <span class="nl">k:</span> <span class="nc">Int</span><span class="o">):</span> <span class="nc">Int</span> <span class="o">{</span>
        <span class="n">val</span> <span class="n">checkStoneSet</span> <span class="o">=</span> <span class="nc">BooleanArray</span><span class="o">(</span><span class="n">stones</span><span class="o">.</span><span class="na">size</span><span class="o">)</span> <span class="o">{</span> <span class="kc">false</span> <span class="o">}</span>
        <span class="n">val</span> <span class="n">stoneSet</span> <span class="o">=</span> <span class="n">mutableSetOf</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;()</span>
        <span class="n">stones</span><span class="o">.</span><span class="na">forEach</span> <span class="o">{</span> <span class="n">stoneSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">it</span><span class="o">)</span> <span class="o">}</span>
        <span class="kt">var</span> <span class="n">sortedStoneSet</span> <span class="o">=</span> <span class="n">stoneSet</span><span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
        <span class="kt">var</span> <span class="n">curStone</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">curStone</span> <span class="o">=</span> <span class="n">sortedStoneSet</span><span class="o">.</span><span class="na">first</span><span class="o">()</span>
        <span class="n">sortedStoneSet</span> <span class="o">=</span> <span class="n">sortedStoneSet</span><span class="o">.</span><span class="na">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">sortedStoneSet</span><span class="o">.</span><span class="na">isNotEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">stones</span><span class="o">.</span><span class="na">forEachIndexed</span><span class="o">{</span> <span class="n">index</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">curStone</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">checkStoneSet</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span> <span class="n">checkStone</span><span class="o">(</span><span class="n">checkStoneSet</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">curStone</span>
            <span class="o">}</span>
            <span class="n">curStone</span> <span class="o">=</span> <span class="n">sortedStoneSet</span><span class="o">.</span><span class="na">first</span><span class="o">()</span>
            <span class="n">sortedStoneSet</span> <span class="o">=</span> <span class="n">sortedStoneSet</span><span class="o">.</span><span class="na">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">curStone</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="n">fun</span> <span class="nf">checkStone</span><span class="o">(</span><span class="nl">stonesList:</span> <span class="nc">BooleanArray</span><span class="o">,</span> <span class="nl">k:</span> <span class="nc">Int</span><span class="o">):</span> <span class="nc">Boolean</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span><span class="o">(</span> <span class="n">i</span> <span class="n">in</span> <span class="n">stonesList</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="n">now</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span> <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">now</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>결과 : 정확성 100% 효율성 0%</li>
</ul>

<p>따라서 이러한 이해를 바탕으로 더 빨리 풀수 있는 방법(스킬)을 찾아야 한다.
결론적으로 찾은 방법은 이분탐색이다.</p>

<p>방법을 구체적으로 설명하자면</p>
<ol>
  <li>구하고자 하는 값을 어떤 로직의 결과로 도출이 내는 것이 아닌, 값을 특정한 다음 해당 값이 조건에 일치한지 검사한다.</li>
  <li>해당 조건에서는 값이 맞는지 틀리는지와 함께 틀리다면 해당 결과값이 조건에 맞는 값과 비교 할수 있으며, 해당 값과 비교하여 크기 여부를 확인한다.</li>
  <li>예상값이 크다면 예상값을 작게, 작다면 예상값을 크게한다. 그렇게 하는 방법은 범주를 정하고 양 끝값의 절반을 예상값으로 한다.(이렇게 이분법으로 나누니 때문에 이분탐색)</li>
  <li>그러나 이 문제에서는 조건에 맞는 값이 여러개가 존재하기 때문에 위 단계에서 추가적으로 조건에 맞는 값이더라도 해당 값중 가장 낮은값을 찾는 upper bound를 로써 문제를 풀어나간다.</li>
</ol>

<p>아래가 해당 방법으로 푼 예시이다.
아래에선 값을 예상할 때, 위에서 완전탐색으로 푼 문제를 통해 결국에는 값이 stones에서 나올수 밖에 없기 때문에 stones의 중복값을 제거하고 정렬을 한 뒤
index 이분탐색을 진행하였다. 물론 러프하게 이분탐색을 진행해도 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">fun</span> <span class="nf">solution</span><span class="o">(</span><span class="nl">stones:</span> <span class="nc">IntArray</span><span class="o">,</span> <span class="nl">k:</span> <span class="nc">Int</span><span class="o">):</span> <span class="nc">Int</span> <span class="o">{</span>
        <span class="n">val</span> <span class="n">stoneSet</span> <span class="o">=</span> <span class="n">mutableSetOf</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;()</span>
        <span class="n">stones</span><span class="o">.</span><span class="na">forEach</span> <span class="o">{</span> <span class="n">stoneSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">it</span><span class="o">)</span> <span class="o">}</span>
        <span class="kt">var</span> <span class="n">sortedStoneSet</span> <span class="o">=</span> <span class="n">stoneSet</span><span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
        
        <span class="kt">var</span> <span class="n">right</span> <span class="o">=</span> <span class="n">sortedStoneSet</span><span class="o">.</span><span class="na">size</span><span class="o">-</span><span class="mi">1</span>
        <span class="kt">var</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="kt">var</span> <span class="nl">mid:</span> <span class="nc">Int</span>
        
        <span class="nf">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>   
            <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span>
            
            <span class="k">if</span><span class="o">(</span><span class="n">checkStone</span><span class="o">(</span><span class="n">stones</span><span class="o">,</span> <span class="n">sortedStoneSet</span><span class="o">[</span><span class="n">mid</span><span class="o">],</span> <span class="n">k</span><span class="o">))</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sortedStoneSet</span><span class="o">[</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">fun</span> <span class="nf">checkStone</span><span class="o">(</span><span class="nl">stones:</span> <span class="nc">IntArray</span><span class="o">,</span> <span class="nl">mid:</span> <span class="nc">Int</span><span class="o">,</span> <span class="nl">k:</span> <span class="nc">Int</span><span class="o">):</span> <span class="nc">Boolean</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span><span class="o">(</span> <span class="n">i</span> <span class="n">in</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="o">)</span> <span class="n">now</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span> <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span><span class="o">(</span><span class="n">now</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

:ET
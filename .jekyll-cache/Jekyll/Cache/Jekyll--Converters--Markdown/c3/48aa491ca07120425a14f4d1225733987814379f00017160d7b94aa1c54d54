I":<h3 id="개요">개요</h3>

<p><code class="language-plaintext highlighter-rouge">let, with, apply, run</code></p>

<p>코틀린을 접하면 공부해야 하는 확장함수이다. 
신입 개발자 면접에서도 각각의 함수를 구분 하는지 알아보는 질문으로 나올만큼 기본적이면서도 중요하다고 할수 있다.</p>

<p>공부하는 방법으로 <code class="language-plaintext highlighter-rouge">어떤 개념에 대해 달달 외우는 것은 도움이 되지 않는다.</code> 라고 생각하지만, 회사에 취직을 하고 싶으니 어쩌겠나 달달 외울 수밖에.</p>

<p>막상 인터뷰 당시 떨려서 잘 대답하지도 못했지만(..) (그래서 달달 외우는건 싫다.)</p>

<p><br /></p>
<blockquote>
  <center>이제는 달달 외우는 것에서 벗어나보자.</center>
  <p><br /></p>
</blockquote>

<p>그렇지만 <code class="language-plaintext highlighter-rouge">let, with, apply, run</code>들에 대해 알고자 하는 포스팅은 아니며, 해당 확장함수를 구성하고 있는 <code class="language-plaintext highlighter-rouge">람다</code>에 대해 알아보고자 한다.</p>

<p>그러면 <code class="language-plaintext highlighter-rouge">let, with, apply, run</code>를 이해하고 적용하는데 더욱 수월할 것이다.</p>

<h3 id="preview">Preview</h3>

<p>람다식에 대해 궁금하게 된 계기는 옵저버 패턴을 다뤘던 이전 포스팅에서 liveData를 최대한 비슷하게 구현해보고자 했던 시도 중 발생한 이슈에서 출발한다. (확장 함수를 구성하고 있는 람다를 이해해서 확장함수를 이해하고 싶어서 출발한 것은 아니다.)</p>

<p>해당 이슈는 <code class="language-plaintext highlighter-rouge">interface를 매개로 사용하는 함수에 대해 람다식을 적용하기 위한 방법</code>에 대한 것인데, 이전 포스팅에서는 interface를 익명 객체로 처리를 했지만 <code class="language-plaintext highlighter-rouge">더욱 깔끔한 코딩</code>을 위해 람다식을 적용하고자 한다면 아래와 같은 2가지 해결방안이 존재한다.</p>

<ol>
  <li>해당 interface를 java로 만든다.</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyObserver</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="nc">String</span> <span class="n">title</span><span class="o">,</span> <span class="nc">String</span> <span class="n">news</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>Kotlin의 버전이 1.4 이상인 버전에 한해서 interface 앞에 fun 키워드를 붙여준다.</li>
</ol>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">fun</span> <span class="nf">interface</span> <span class="nc">MyObserver</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">update</span><span class="p">(</span><span class="n">title</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="n">news</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이 포스팅은 여기서 부터 출발 한다.</p>

<h3 id="functional-interface---lambda-expression">Functional Interface - Lambda Expression</h3>

<p>사실 람다식이 도입된 이유는 Preview에서 람다식으로 적용하고자 하는 이유 - <code class="language-plaintext highlighter-rouge">interface를 익명객체로 처리하기 보다 더욱 깔큼한 코딩</code>와 같다.</p>

<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27">우선 Java Specification에선 람다식에 대해 다음과 같이 설명하고 있다.</a></p>

<blockquote>
  <p>A lambda expression is like a method: it provides a list of formal parameters and a body - an expression or block - expressed in terms of those parameters.</p>

  <p>(중간 생략)</p>

  <p>Evaluation of a lambda expression produces an instance of a functional interface (§9.8). Lambda expression evaluation does not cause the execution of the expression’s body; instead, this may occur at a later time when an appropriate method of the functional interface is invoked.</p>

  <p>람다식은 메소드와 비슷하다: 규격을 갖춘 파라미터의 목록과 그 파라미터를 이용해서 표현된 몸통(표현식이든 블록이든)을 제공한다.</p>

  <p>(중간 생략)</p>

  <p>람다식이 평가(evaluation)되면 그 결과 Functional Interface의 인스턴스를 생성한다. 람다식의 처리 결과는 표현식 몸통을 실행하는 것이 아니다; 대신 나중에 이 Functional Interface의 적절한 메소드가 실제 호출(invoke)될 때 이것(표현식 몸통의 실행)이 일어난다.</p>
</blockquote>

:ET